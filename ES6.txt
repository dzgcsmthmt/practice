let constant
let 声明的变量仅在块级作用域内有效
let 不存在声明提升
ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。
变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。
let不允许在相同作用域内，重复声明同一个变量。
const声明一个只读的常量。一旦声明，常量的值就不能改变。
const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
const不改变引用，可以赋值
块级作用域和函数声明
--允许在块级作用域内声明函数。
--函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
--同时，函数声明还会提升到所在的块级作用域的头部。
-----------------------------------------------------------------------------------------------------------------------
正则的拓展
1、ES5不允许此时使用第二个参数，添加修饰符，否则会报错，ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
2、添加了u修饰符和y修饰符 
----ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。
----y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
3、ES5添加了source属性，ES6添加sticky属性和flags属性
-----------------------------------------------------------------------------------------------------------------------
