let constant
let 声明的变量仅在块级作用域内有效
let 不存在声明提升
ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。
变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。
let不允许在相同作用域内，重复声明同一个变量。
const声明一个只读的常量。一旦声明，常量的值就不能改变。
const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
const不改变引用，可以赋值
块级作用域和函数声明
--允许在块级作用域内声明函数。
--函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
--同时，函数声明还会提升到所在的块级作用域的头部。
-----------------------------------------------------------------------------------------------------------------------
变量的解构赋值
1、数组的解构赋值 let [a,b] = [1,2]  ==> a = 1;b = 2  这个赋值在编译阶段执行 ？？？？这个还需要找资料确认
----这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，解构不成功，变量的值就等于undefined
----只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。
----解构赋值允许指定默认值。如果默认值是一个表达式，那么这个表达式是惰性求值的
function f() {
  console.log('aaa');
}
let [x = f()] = [1]; 为1不会执行f(),undefined才执行
2、对象的解构赋值 { foo, bar } = { foo: "aaa", bar: "bbb" }; foo ==> 'aaa'
{ foo, bar } == {foo: foo,bar: bar} 利用了对对象的拓展
3、字符串的解构赋值 const [a, b, c, d, e] = 'hello'; a ==> h  let {length : len} = 'hello'; len ==> 5
4、数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
let {toString: s} = 123;
s === Number.prototype.toString // true
let {toString: s} = true;
s === Boolean.prototype.toString // true
5、函数参数的解构赋值   函数参数的解构也可以使用默认值
function add([x, y]){
  return x + y;
}
add([1, 2]); // 3
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
-----------------------------------------------------------------------------------------------------------------------
正则的拓展
1、ES5不允许此时使用第二个参数，添加修饰符，否则会报错，ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
2、添加了u修饰符和y修饰符 
----ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。
----y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
3、ES5添加了source属性，ES6添加sticky属性和flags属性
-----------------------------------------------------------------------------------------------------------------------
数值的拓展
都是针对Number类型判断，不会类型转换
二进制和八进制表示法 ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
Number.isFinite(), Number.isNaN() Number.isNaN('ddd') == > false isNaN('ddd') ==> true
Number.parseInt(), Number.parseFloat() 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
Number.isInteger() 在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。
Number.EPSILON 新增一个极小的常量Number.EPSILON // 2.220446049250313e-16
--但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 return Math.abs(left - right) < Number.EPSILON;
安全整数和Number.isSafeInteger() JavaScript能够准确表示的整数范围在-2^53到2^53之间
Math对象的扩展
--Math.trunc方法用于去除一个数的小数部分，返回整数部分。
--Math.sign方法用来判断一个数到底是正数、负数、还是零。 其他值，返回NaN。
--Math.cbrt方法用于计算一个数的立方根。
--Math.clz32() JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。
-----------------------------------------------------------------------------------------------------------------------
数组的拓展
1、Array.from() 把类数组转换为真正的数组，ES5的[].splice.call等价  支持3个参数，第2个参数是一个类似map的函数，第3个参数绑定this
2、Array.of() 用于将一组值，转换为数组。主要目的，是弥补数组构造函数Array()的不足。new Array(3)会生成一个length为3的数组 Array.of(3) ==> [3]
3、Array.copyWithin(target, start,end) 使用这个方法，会修改当前数组
----target（必需）：从该位置开始替换数据。
----start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
----end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 
[1, 2, 3, 4, 5].copyWithin(0, 3) ==> [4, 5, 3, 4, 5],如果start > end返回原数组，不能转换为数字的也返回原数组，不会报错
4、Array.find() Array.findIndex() 一个返回值，一个返回索引,第二个参数可以用来绑定this
参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。
如果没有符合条件的成员，find返回undefined，findIndex返回-1
5、Array.fill() 方法使用给定值，填充一个数组，3个参数 填充值，开始位置和结束位置
6、Array.includes() 可以正确判断NaN
-----------------------------------------------------------------------------------------------------------------------

