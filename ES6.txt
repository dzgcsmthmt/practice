let constant
let 声明的变量仅在块级作用域内有效
let 不存在声明提升
ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。
变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。
let不允许在相同作用域内，重复声明同一个变量。
const声明一个只读的常量。一旦声明，常量的值就不能改变。
const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
const不改变引用，可以赋值
块级作用域和函数声明
--允许在块级作用域内声明函数。
--函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
--同时，函数声明还会提升到所在的块级作用域的头部。
-----------------------------------------------------------------------------------------------------------------------
正则的拓展
1、ES5不允许此时使用第二个参数，添加修饰符，否则会报错，ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
2、添加了u修饰符和y修饰符 
----ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。
----y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
3、ES5添加了source属性，ES6添加sticky属性和flags属性
-----------------------------------------------------------------------------------------------------------------------
数组的拓展
1、Array.from() 把类数组转换为真正的数组，ES5的[].splice.call等价  支持3个参数，第2个参数是一个类似map的函数，第3个参数绑定this
2、Array.of() 用于将一组值，转换为数组。主要目的，是弥补数组构造函数Array()的不足。new Array(3)会生成一个length为3的数组 Array.of(3) ==> [3]
3、Array.copyWithin(target, start,end) 使用这个方法，会修改当前数组
----target（必需）：从该位置开始替换数据。
----start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
----end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 
[1, 2, 3, 4, 5].copyWithin(0, 3) ==> [4, 5, 3, 4, 5],如果start > end返回原数组，不能转换为数字的也返回原数组，不会报错
4、Array.find() Array.findIndex() 一个返回值，一个返回索引,第二个参数可以用来绑定this
参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。
如果没有符合条件的成员，find返回undefined，findIndex返回-1
5、Array.fill() 方法使用给定值，填充一个数组，3个参数 填充值，开始位置和结束位置
6、Array.includes() 可以正确判断NaN
-----------------------------------------------------------------------------------------------------------------------

